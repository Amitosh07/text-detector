STRUCTURED 
QUERY LANGUAGE
1

2
Recap
Introduction to SQL
DDL Statements
◦Create Table
◦Alter Table
◦Drop Table
◦Truncate Table
DML Statements
◦Insert into
◦Delete from
◦Select …
◦Update …

Aggregate Functions

4
SUM( ) , AVG( ) , MAX( ) , MIN( ), COUNT( )
SQL - Aggregate  functions
Used when information you want to extract from a table has to 
do with the data in the entire table taken as a set.
Aggregate functions are used in place of column names in the 
SELECT  statement
The aggregate functions in sql are :
SUM ( [ DISTINCT ] column-name  /  expression )
AVG ( [ DISTINCT ] column-name / expression )
MIN ( expression)
MAX ( expression )
COUNT ( [ DISTINCT ] column-name )
COUNT ( *)
Group functions do not process NULL values and do not return a NULL value, even 
when NULL are the only values evaluated. For example, a COUNT or SUM of NULL 
values will result in 0..

5
List the minimum unit price from item table. 
SELECT MIN (UnitPrice)
FROM Item;
Aggregate  function - MIN
Returns the smallest value that occurs in the specified column
Column need not be numeric type 
MIN:
This function has the syntax MIN([{DISTINCT | ALL }] <x>), where x is an expression. This function 
returns the lowest value in the expression x.
•If the expression x is a date data type, it returns a DATE. For dates, the minimum is the earliest 
date.
•If the expression x is a numeric data type, it returns a NUMBER. For numbers, the minimum is the 
smallest number.
•If the expression is a character data type, it returns a VARCHAR2. for character strings, the 
minimum is the one that sorts lowest based on the database character set.

6
List the maximum Unit price in the item table.
SELECT MAX (UnitPrice)
FROM Item;
Aggregate  function - MAX
Returns the largest value that occurs in the specified column
Column need not be numeric type
Example:
MAX:
This function has the syntax MAX([{DISTINCT | ALL }] <x>), where x is an expression. This 
function returns the highest value in the expression x.
•If the expression x is a date data type, it returns a DATE. For dates, the maximum is the latest 
date.
•If the expression x is a numeric data type, it returns a NUMBER. For numbers, the maximum is 
the largest number.
•If the expression is a character data type, it returns a VARCHAR2. for character strings, the 
maximum is the one that sorts highest based on the database character set.

7
Example:
List the average Unit price of Class A items in the item table.
SELECT AVG (UnitPrice)
FROM Item 
where Class=‘A’;
Aggregate  function - AVG
Returns the average of all the values in the specified column
Column must be numeric data type
NULL values do not participate in average computation 
AVG: 
This function has the syntax AVG ( [DISTINCT | ALL] <n>), where n is a  numeric 
expression. The AVG function returns the avearge of the expression n. If neither 
DISTINCT nor ALL is specified in the function call, the default is ALL.

8
List the minimum and Sum of all the Unit price of items in the item table.
SELECT MIN(UnitePrice),SUM (UnitPrice) 
FROM Item;
Aggregate  function - SUM
Adds up the values in the specified column
Column must be numeric data type 
Value of the sum must be within the range of that data type
Example:

9
List total number of items in the item table.
SELECT COUNT (*)
FROM Item;
Aggregate  function - COUNT
Returns the number of rows in the table
List the total number of customer who have their date of registration 
information in the customer table.
SELECT COUNT (DateOfReg)
FROM Costomer;
Count(*) 
= 
No of rows, regardless of NULLs
Count(ColumnName) 
=   
No. of rows that do not have  NULL Value
COUNT:
The COUNT function returns the number of rows in the query. 
The asterisk (*) is a special quantity – it counts all rows in the result set, regardless 
of NULLs.

Aggregate  function - COUNT
List total number of unique Dates on which Bill has been generated.
SELECT COUNT (DISTINCT BillDate)
FROM Bill;
Count(*) 
=      No of rows, regardless of NULLs
Count(ColumnName) 
=   
No. of rows that do not have  NULL Value

REFERENTIAL INTEGRITY 
OPTIONS
We can specify  CASCADE, SET NULL or SET DEFAULT on 
referential integrity constraints (foreign keys)
CREATE TABLE   DEPT
(
DNAME
VARCHAR(10) NOT NULL,
DNUMBER
INTEGER
NOT NULL,
MGRSSN
CHAR(9),
MGRSTARTDATE
CHAR(9),
PRIMARY KEY (DNUMBER),
UNIQUE (DNAME),
FOREIGN KEY (MGRSSN) REFERENCES EMP
ON DELETE CASCADE  );

12
ON DELETE CASCADE
It specifies that the child data is deleted when the parent data is deleted.
ON UPDATE
Optional. It specifies what to do with the child data when the parent data is updated. 
You have the options of NO ACTION, CASCADE, SET NULL, or SET DEFAULT.
NO ACTION
It is used in conjunction with ON DELETE or ON UPDATE. It means that no action is 
performed with the child data when the parent data is deleted or updated.
CASCADE
It is used in conjunction with ON DELETE or ON UPDATE. It means that the child data 
is either deleted or updated when the parent data is deleted or updated.
SET NULL
It is used in conjunction with ON DELETE or ON UPDATE. It means that the child data 
is set to NULL when the parent data is deleted or updated.
SET DEFAULT
It is used in conjunction with ON DELETE or ON UPDATE. It means that the child data 
is set to their default values when the parent data is deleted or updated.

Retrieval Queries in SQL
Basic form of the SQL SELECT statement is called a mapping or a 
SELECT-FROM-WHERE block
SELECT
<attribute list>
FROM
<table list>
WHERE
<condition>
◦<attribute list> is a list of attribute names whose values are to be retrieved 
by the query
◦<table list> is a list of the relation names required to process the query
◦<condition> is a conditional (Boolean) expression that identifies the tuples to 
be retrieved by the query

Relational Database Schema--Figure 5.5

Populated Database--Fig.5.6

Simple SQL Queries
Basic SQL queries correspond to using the SELECT, PROJECT, and JOIN operations of the 
relational algebra
All subsequent examples use the COMPANY database
Example of a simple query on one relation
Query 0: Retrieve the birthdate and address of the employee whose name is 'John B. 
Smith'.
Q0:
SELECT 
BDATE, ADDRESS
FROM 
EMPLOYEE
WHERE
FNAME='John' AND MINIT=‘B’ AND LNAME='Smith’
◦Similar to a SELECT-PROJECT pair of relational algebra operations; the SELECT-clause specifies the 
projection attributes and the WHERE-clause specifies the selection condition
◦However, the result of the query may contain duplicate tuples

Simple SQL Queries (cont.)
Query 1: Retrieve the name and address of all employees who work for 
the 'Research' department.
Q1:
SELECT FNAME, LNAME, ADDRESS
FROM 
EMPLOYEE, DEPARTMENT
WHERE DNAME='Research' AND DNUMBER=DNO
◦Similar to a SELECT-PROJECT-JOIN sequence of relational algebra 
operations
◦(DNAME='Research') is a selection condition (corresponds to a 
SELECT operation in relational algebra)
◦(DNUMBER=DNO) is a join condition (corresponds to a JOIN 
operation in relational algebra)

Simple SQL Queries (cont.)
Query 2: For every project located in 'Stafford', list the project number, the 
controlling department number, and the department manager's last name, address, 
and birthdate.
Q2:
SELECT PNUMBER, DNUM, LNAME, BDATE, ADDRESS 
FROM
PROJECT, DEPARTMENT, EMPLOYEE
WHERE DNUM=DNUMBER AND MGRSSN=SSN AND PLOCATION='Stafford'
◦In Q2, there are two join conditions
◦The join condition DNUM=DNUMBER relates a project to its controlling 
department
◦The join condition MGRSSN=SSN relates the controlling department to the 
employee who manages that department

19
Use Like, binary operator for comparing strings
%, wild card for strings 
_, wild card for characters 
||, concatenate operation for strings 
Substring Comparisons

20
Retrieve all products which product name begins with C
SELECT ProductID, ProductName
FROM products
WHERE ProductName LIKE 'C%’;
Use lower-case c for the pattern which returns
-- the same result as Query 1.
SELECT ProductID, ProductName
FROM products
WHERE ProductName LIKE 'c%';
(name like ‘%a_‘) is true for all names having a as second letter from the end

21
LIKE Operator
Description
WHERE CustomerName LIKE 
'a%'
Finds any values that starts with 
"a"
WHERE CustomerName LIKE 
'%a'
Finds any values that ends with "a"
WHERE CustomerName LIKE 
'%or%'
Finds any values that have "or" in 
any position
WHERE CustomerName LIKE 
'_r%'
Finds any values that have "r" in 
the second position
WHERE CustomerName LIKE 
'a__%'
Finds any values that starts with 
"a" and are at least 3 characters in 
length
WHERE ContactName LIKE 
'a%o'
Finds any values that starts with 
"a" and ends with "o"

22
SELECT first_name || ‘ ‘ || last_name AS full_name
FROM student;
||, concatenate operation for strings 
This query returns records in one column named full_name:
You can also use a special function: CONCAT. 
It takes a list of strings or names of columns to join as arguments:
SELECT CONCAT(first_name, ‘ ‘, last_name) AS full_name FROM student;
SELECT CONCAT('SQL', ' ', 'is', ' ', 'fun!');
SQL is fun!
Result:

Aliases, * and DISTINCT, Empty 
WHERE-clause
In SQL, we can use the same name for two (or more) attributes as long 
as the attributes are in different relations
A query that refers to two or more attributes with the same name must 
qualify the attribute name with the relation name by prefixing the 
relation name to the attribute name
Example:
EMPLOYEE.LNAME, DEPARTMENT.DNAME

24
You can rename a table or a column temporarily by giving another name known 
as Alias. The use of table aliases is to rename a table in a specific SQL statement.
The renaming is a temporary change and the actual table name does not change in 
the database. 
The column aliases are used to rename a table's columns for the purpose of a 
particular SQL query.
SQL - Alias
The basic syntax of a table alias is as 
follows.
SELECT column1, column2....
FROM table_name AS alias_name
WHERE [condition];
The basic syntax of a column alias is as 
follows.
SELECT column_name AS alias_name
FROM table_name
WHERE [condition];

25
Table 1 − CUSTOMERS Table is as 
follows.
+----+----------+-----+-----------+----------+
| ID | NAME     | AGE | ADDRESS   | SALARY   |
+----+----------+-----+-----------+----------+
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 
|  2 | Khilan |  25 | Delhi     |  1500.00 |
|  3 | kaushik |  23 | Kota      |  2000.00 |
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |
|  6 | Komal    |  22 | MP        |  4500.00 |
|  7 | Muffy    |  24 | Indore    | 10000.00 |
+----+----------+-----+-----------+----------+
Table 2 − ORDERS Table is as follows.
+-----+---------------------+-------------+--------+
|OID  | DATE                | CUSTOMER_ID | AMOUNT
+-----+---------------------+-------------+--------+
| 102 | 2009-10-08 00:00:00 |           3 |   3000 |
| 100 | 2009-10-08 00:00:00 |           3 |   1500 |
| 101 | 2009-11-20 00:00:00 |           2 |   1560 |
| 103 | 2008-05-20 00:00:00 |           4 |   2060 |
+-----+---------------------+-------------+--------+
Table alias.
SELECT C.ID, C.NAME, C.AGE, O.AMOUNT 
FROM CUSTOMERS AS C, ORDERS AS O
WHERE  C.ID = O.CUSTOMER_ID;
+----+----------+-----+--------+
| ID | NAME     | AGE | AMOUNT |
+----+----------+-----+--------+
|  3 | kaushik |  23 |   3000 |
|  3 | kaushik |  23 |   1500 |
|  2 | Khilan |  25 |   1560 |
|  4 | Chaitali |  25 |   2060 |
+----+----------+-----+--------+

26
Column Alias.
SELECT  ID AS CUSTOMER_ID, NAME AS CUSTOMER_NAME
FROM CUSTOMERS
WHERE SALARY IS NOT NULL;
+-------------+---------------+
| CUSTOMER_ID | CUSTOMER_NAME |
+-------------+---------------+
|           1 | Ramesh        |
|           2 | Khilan
|
|           3 | kaushik
|
|           4 | Chaitali
|
|           5 | Hardik        |
|           6 | Komal         |
|           7 | Muffy         |
+-------------+---------------+

ALIASES
Some queries need to refer to the same relation twice
In this case, aliases are given to the relation name
Query 8: For each employee, retrieve the employee's name, and the name of his or 
her immediate supervisor.
Q8:
SELECT E.FNAME, E.LNAME, S.FNAME, S.LNAME
FROM 
EMPLOYEE E S
WHERE E.SUPERSSN=S.SSN
◦In Q8, the alternate relation names E and S are called aliases or tuple variables for 
the EMPLOYEE relation
◦We can think of E and S as two different copies of EMPLOYEE; E represents 
employees in role of supervisees and S represents employees in role of supervisors

ALIASES (cont.)
◦Aliasing can also be used in any SQL query for convenience
Can also use the AS keyword to specify aliases
Q8: SELECT E.FNAME, E.LNAME, S.FNAME, S.LNAME
FROM 
EMPLOYEE AS E, EMPLOYEE AS S
WHERE E.SUPERSSN=S.SSN

UNSPECIFIED WHERE-clause
A missing WHERE-clause indicates no condition; hence, all tuples of 
the relations in the FROM-clause are selected
This is equivalent to the condition WHERE TRUE
Query 9: Retrieve the SSN values for all employees.
Q9:
SELECT SSN
FROM EMPLOYEE
If more than one relation is specified in the FROM-clause and there is 
no join condition, then the CARTESIAN PRODUCT of tuples is selected

UNSPECIFIED WHERE-clause (cont.)
Example:
Q10: SELECTSSN, DNAME
FROM EMPLOYEE, DEPARTMENT

USE OF *
To retrieve all the attribute values of the selected tuples, a * is used, 
which stands for all the attributes
Examples:
Q1C: SELECT *
FROM EMPLOYEE
WHERE DNO=5
Q1D: SELECT*
FROM EMPLOYEE, DEPARTMENT
WHERE DNAME='Research' AND DNO=DNUMBER

USE OF DISTINCT
SQL does not treat a relation as a set; duplicate tuples can appear
To eliminate duplicate tuples in a query result, the keyword 
DISTINCT is used
For example, the result of Q11 may have duplicate SALARY values 
whereas Q11A does not have any duplicate values
Q11: SELECT SALARY
FROM EMPLOYEE
Q11A: SELECT DISTINCT SALARY
FROM EMPLOYEE

SET OPERATIONS
SQL has directly incorporated some set operations
There is a union operation (UNION), set difference (MINUS)
and intersection (INTERSECT) operations
The resulting relations of these set operations are sets of 
tuples; duplicate tuples are eliminated from the result
The set operations apply only to union compatible relations ; 
the two relations must have the same attributes and the 
attributes must appear in the same order

SET OPERATIONS (cont.)
Query 4: Make a list of all project numbers for projects that involve an employee 
whose last name is 'Smith' as a worker or as a manager of the department that 
controls the project.
Q4:
(SELECT  PNAME
FROM
PROJECT, DEPARTMENT, EMPLOYEE
WHERE DNUM=DNUMBER AND MGRSSN=SSN AND LNAME='Smith')
UNION
(SELECT  PNAME FROM PROJECT, WORKS_ON, EMPLOYEE
WHERE PNUMBER=PNO AND ESSN=SSN AND LNAME='Smith')

35
Built-in Functions
LENGTH (string): The Oracle/PLSQL LENGTH function returns the length of the 
specified string. 
Syntax: LENGTH( string1) 
LOWER (string): The Oracle/PLSQL LOWER function converts all letters in the 
specified string to lowercase. If there are characters in the string that are not letters, they are 
unaffected by this function. 
Syntax: LOWER(string) 
SUBSTR (string, start, count): The Oracle/PLSQL SUBSTR functions allows you to extract 
a substring from a string. 
Syntax: SUBSTR(string, start_position [, length ] ) 
Or         SUBSTR(string FROM start FOR length)
List the department names and 3 characters from 3rd position of each department name 
select dept_name, substr(dept_name, 3, 3) from department;

36
UPPER (string):The Oracle/PLSQL UPPER function converts all letters in the specified 
string to uppercase. If there are characters in the string that are not letters, they are 
unaffected by this function. 
Syntax: UPPER (string) 
TO_CHAR (date1, format): The Oracle/PLSQL TO_CHAR function converts a number 
or date to a string. 
SELECT last_name,
TO_CHAR(hire_date, ‘DD Month YYYY’)
AS HIREDATE
FROM employees;
LASTNAME
HIREDATE
Austin
25 January 2005
Shubham
20 June 2004
Nishant
15 January 1999

37
NVL Function
The Oracle/PLSQL NVL function lets you substitute a value when a null value is 
encountered.
Syntax
NVL( string1, replace_with )
string1
The string to test for a null value.
replace_with
The value returned if string1 is null.
Example
SELECT NVL(supplier_city, 'n/a')
FROM suppliers;
The SQL statement above would return 'n/a' if the supplier_city field contained a null 
value. Otherwise, it would return the supplier_city value.

38
ROUND (value, precision): The Oracle/PLSQL ROUND function returns a number 
rounded to a certain number of decimal places. 
Syntax: ROUND (number [, decimal places]) 
SELECT 1.20 as Value, ROUND(1.20,1) AS 
Round(value,1)
UNION
SELECT 1.22 as Value, ROUND(1.22,1) AS 
Round(value,1)
UNION
SELECT 1.25 as Value, ROUND(1.25,1) AS 
Round(value,1)
UNION
SELECT 1.27 as Value, ROUND(1.27,1) AS 
Round(value,1)
Value
Round(value,1)
1.20
1.2
1.22
1.2
1.25
1.3
1.27
1.3

39
SELECT 12345 as Value, ROUND(12345,-2) AS 
Round(value,-2)
UNION
SELECT 12355 as Value, ROUND(12355,-2) AS 
Round(value,-2)
UNION
SELECT 12350 as Value, ROUND(12350,-2) AS 
Round(value,-2)
UNION
SELECT 101 as Value, ROUND(101,-2) AS 
Round(value,-2)
UNION
SELECT 199 as Value, ROUND(199,-2) AS 
Round(value,-2)
UNION
SELECT 99 as Value, ROUND(99,-2) AS 
Round(value,-2)
Value
Round(value, -
2)
12345
12300
12355
12400
12350
12400
101
100
199
200
99
100

40
LAST_DAY(date):The Oracle/PLSQL LAST_DAY function returns the last day of the 
month based on a date value.
Syntax: LAST_DAY(date) 
MONTHS_BETWEEN (date1, date2):The Oracle/PLSQL MONTHS_BETWEEN 
function returns the number of months between date1 and date2. 
Syntax: MONTHS_BETWEEN (date1, date2) 
NEXT_DAY(date1, ‘day’):The Oracle/PLSQL NEXT_DAY function returns the first 
weekday that is greater than a date. 
Syntax: NEXT_DAY (date, weekday)

41
TO_DATE (string, ‘format’):The Oracle/PLSQL TO_DATE function converts a string to a 
date. 
Syntax:TO_DATE( string1 [, format_mask] [, nls_language] ) 
Ex: to_date (‘12021998’, ‘DDMMYYYY’) 

NESTING OF QUERIES
A complete SELECT query, called a nested query , can be specified within the 
WHERE-clause of another query, called the outer query
Many of the previous queries can be specified in an alternative form using 
nesting
Query 1: Retrieve the name and address of all employees who work for the 
'Research' department.
Q1:
SELECT
FNAME, LNAME, ADDRESS
FROM 
EMPLOYEE
WHERE DNO IN  
(SELECT  DNUMBER
FROM
DEPARTMENT
WHERE DNAME='Research' )

NESTING OF QUERIES (cont.)
The nested query selects the number of the 'Research' department
The outer query select an EMPLOYEE tuple if its DNO value is in the result of either 
nested query
The comparison operator IN compares a value v with a set (or multi-set) of values V, 
and evaluates to TRUE if v is one of the elements in V
In general, we can have several levels of nested queries

CORRELATED NESTED QUERIES
If a condition in the WHERE-clause of a nested query references an attribute of a 
relation declared in the outer query , the two queries are said to be correlated
The result of a correlated nested query is different for each tuple (or combination of 
tuples) of the relation(s) the outer query
Query 12: Retrieve the name of each employee who has a dependent with the same 
first name as the employee.
Q12: SELECT  
E.FNAME, E.LNAME
FROM
EMPLOYEE AS E
WHERE E.SSN IN (SELECT ESSN
FROM
DEPENDENT
WHERE ESSN=E.SSN AND E.FNAME=DEPENDENT_NAME)

CORRELATED NESTED QUERIES 
(cont.)
◦In Q12, the nested query has a different result for each tuple in the outer query
◦A query written with nested SELECT... FROM... WHERE... blocks and using the = or IN 
comparison operators can always be expressed as a single block query. For example, Q12 
may be written as in Q12A
Q12A:
SELECT 
E.FNAME, E.LNAME
FROM
EMPLOYEE E, DEPENDENT D
WHERE
E.SSN=D.ESSN AND E.FNAME=D.DEPENDENT_NAME
◦The original SQL as specified for SYSTEM R also had a CONTAINS comparison operator, which 
is used in conjunction with nested correlated queries
◦This operator was dropped from the language, possibly because of the difficulty in 
implementing it efficiently

CORRELATED NESTED QUERIES 
(cont.)
◦Most implementations of SQL do not have this operator
◦The CONTAINS operator compares two sets of values , and returns TRUE if one 
set contains all values in the other set
◦Query 3: Retrieve the name of each employee who works on all the projects 
controlled by department number 5.
Q3: SELECT 
FNAME, LNAME
FROM
EMPLOYEE
WHERE  ( (SELECT
PNO FROM WORKS_ON   WHERE SSN=ESSN)
CONTAINS
(SELECT PNUMBER FROM PROJECT WHERE DNUM=5) )

THE EXISTS FUNCTION
EXISTS is used to check whether the result of a correlated nested query 
is empty (contains no tuples) or not
We can formulate Query 12 in an alternative form that uses EXISTS as 
Q12B below
Query 12: Retrieve the name of each employee who has a dependent with the same 
first name as the employee.
Q12B: 
SELECT  FNAME, LNAME
FROM
EMPLOYEE
WHERE EXISTS  
(SELECT
* FROM
DEPENDENT WHERE SSN=ESSN AND
FNAME=DEPENDENT_NAME)

THE EXISTS FUNCTION (cont.)
Query 6: Retrieve the names of employees who have no dependents.
Q6:
SELECT  
FNAME, LNAME
FROM EMPLOYEE
WHERE
NOT EXISTS   (SELECT *
FROM  DEPENDENT
WHERE SSN=ESSN)

49
SELECT fname, lname
FROM Customers 
WHERE EXISTS (SELECT * 
FROM Orders 
WHERE Customers.customer_id = Orders.c_id);
SELECT lname, fname
FROM Customer
WHERE NOT EXISTS (SELECT * 
FROM Orders 
WHERE Customers.customer_id = Orders.c_id);

EXPLICIT SETS
It is also possible to use an explicit (enumerated) set of 
values in the WHERE-clause rather than a nested query
Query 13: Retrieve the social security numbers of all 
employees who work on project number 1, 2, or 3.
Q13: SELECT DISTINCT ESSN
FROM WORKS_ON
WHERE PNO IN  (1, 2, 3)

NULLS IN SQL QUERIES
SQL allows queries that check if a value is NULL (missing or 
undefined or not applicable)
SQL uses IS or IS NOT to compare NULLs.
Query 14: Retrieve the names of all employees who do not 
have supervisors.
Q14: SELECT   FNAME, LNAME
FROM EMPLOYEE
WHERE SUPERSSN  IS  NULL
Note: If a join condition is specified, tuples with NULL values 
for the join attributes are not included in the result

Grouping Data with Group By

53
SQL - Using  GROUP BY
Related rows can be grouped together by GROUP BY clause by 
specifying a column as a grouping column.
GROUP BY is associated with an aggregate function
To retrieve the average unit price of all class of items available in the item table.
SELECT  Class,
AVG(UnitPrice) 
FROM Item  
GROUP BY  Class;
Column name can 
come along with 
aggregate function 
only if it appears in 
Group by clause
In the output table all the rows with an identical value in the grouping column will be 
grouped together. 
Note: The GROUP BY statement is often used with aggregate functions 
(COUNT(), MAX(), MIN(), SUM(), AVG()) to group the result-set by one or more columns.

54
SQL – Group By
SELECT  Class,
AVG(UnitPrice) 
FROM Item  
GROUP BY  Class;
Class
AVG(UnitPrice)
A
20
B
400
C
5000
Item
ItemId
ItemName
UnitPrice
Class
SupplierId
STN001 Pen
30
A
S1
BAK003 Bread
20
A
S4
GRO001 Poteto 
10
A
S3
ELC001
Mobile
5000
C
S2
ELC004
iPod
600
B
S2
STN002 Diary
200
B
S2

55
Example:
Invalid SQL statement
SELECT Class, SupplierId, COUNT(ItemId)
FROM Item
GROUP BY Class;
Valid SQL Statement
SELECT Class, SupplierId, COUNT(ItemId)
FROM Item
GROUP BY Class, SupplierId;
Retrieval using  GROUP BY

56
SQL – Group By
Item
ItemId
ItemName
UnitPrice
Class
SupplierId
STN001
Pen
30
A
S1
BAK003
Bread
20
A
S4
GRO001
Poteto 
10
A
S3
ELC001
Mobile
5000
C
S2
ELC004
iPod
600
B
S2
STN002
Diary
200
B
S2
SELECT Class, SupplierId, COUNT(ItemId)
FROM Item GROUP BY Class, SupplierId;
Class
SupplierId
Count(ItemId)
A
S1
1
A
S3
1
A
S4
1
B
S2
2
C
S2
1

57
List all the classes of item whose average unit price is greater than 500
SELECT Class, AVG( UnitPrice)
FROM Item
GROUP BY Class   
HAVING AVG(UnitPrice) > 400;
Retrieval using  HAVING

58
SELECT Class, AVG( UnitPrice) FROM Item
GROUP BY Class HAVING AVG(UnitPrice) >= 400;
Retrieval using  HAVING
Item
ItemId
ItemName
UnitPrice
Class
SupplierId
STN001
Pen
30
A
S1
BAK003
Bread
20
A
S4
GRO001
Poteto 
10
A
S3
ELC001
Mobile
5000
C
S2
ELC004
iPod
600
B
S2
STN002
Diary
200
B
S2
Class
AVG(UnitPrice)
A
20
B
400
C
5000
Class
AVG(UnitPrice)
B
400
C
5000
After Grouping
After Having

ORDER BY
The ORDER BY clause is used to sort the tuples in a query 
result based on the values of some attribute(s)
Query 28: Retrieve a list of employees and the projects each 
works in, ordered by the employee's department, and within 
each department ordered alphabetically by employee last 
name.
Q28: 
SELECT DNAME, LNAME, FNAME, PNAME
FROM 
DEPARTMENT, EMPLOYEE, WORKS_ON, PROJECT
WHERE DNUMBER=DNO AND SSN=ESSN AND PNO=PNUMBER
ORDER BY
DNAME, LNAME

ORDER BY (cont.)
The default order is in ascending order of values
We can specify the keyword DESC if we want a
descending order; the keyword ASC can be used to
explicitly specify ascending order, even though it is the
default

61
SELECT * FROM Student ORDER BY ROLL_NO DESC;
ROLL_NO
NAME
ADDRESS
PHONE
Age
8
NIRAJ
ALIPUR
XXXXXXXXXX
19
7
ROHIT
BALURGHAT
XXXXXXXXXX
18
6
DHANRAJ
BARABAJAR
XXXXXXXXXX
20
5
SAPTARHI
KOLKATA
XXXXXXXXXX
19
4
DEEP
RAMNAGAR
XXXXXXXXXX
18
3
RIYANKA
SILIGURI
XXXXXXXXXX
20
2
PRATIK
BIHAR
XXXXXXXXXX
19
1
HARSH
DELHI
XXXXXXXXXX
18

62
SELECT * FROM Student ORDER BY Age ASC , ROLL_NO DESC;
ROLL_NO
NAME
ADDRESS
PHONE
Age
7
ROHIT
BALURGHAT
XXXXXXXXXX
18
4
DEEP
RAMNAGAR
XXXXXXXXXX
18
1
HARSH
DELHI
XXXXXXXXXX
18
8
NIRAJ
ALIPUR
XXXXXXXXXX
19
5
SAPTARHI
KOLKATA
XXXXXXXXXX
19
2
PRATIK
BIHAR
XXXXXXXXXX
19
6
DHANRAJ
BARABAJAR
XXXXXXXXXX
20
3
RIYANKA
SILIGURI
XXXXXXXXXX
20

CTE (Common Table Expressions)
What is a CTE?
Every query generates a temporary result or relation. In order to give a name to 
those temporary result set, CTE is used.
A CTE is defined using WITH clause.
Using WITH clause we can define more than one CTEs in a single statement.
A CTE can be referenced in the other CTEs that are part of same WITH clause 
but those CTEs should be defined earlier.
The scope of every CTE exist within the statement in which it is defined.

64
WITH Clause
The SQL WITH clause was introduced by Oracle in the Oracle 9i release 2 database. The SQL
WITH clause allows you to give a sub-query block a name (a process also called sub-query
refactoring), which can be referenced in several places within the main SQL query.
•The clause is used for defining a temporary relation such that the output of this temporary 
relation is available and is used by the query that is associated with the WITH clause.
•Queries that have an associated WITH clause can also be written using nested sub-queries 
but doing so add more complexity to read/debug the SQL query.
•WITH clause is not supported by all database system.
•The name assigned to the sub-query is treated as though it was an view or table

65
Syntax:
WITH temporaryTable (averageValue) as
(SELECT avg(Attr1)
FROM Table)
SELECT Attr1
FROM Table, temporaryTable
WHERE Table.Attr1 > temporaryTable.averageValue;
In this query, WITH clause is used to define a temporary relation temporaryTable that has 
only 1 attribute averageValue. averageValue holds the average value of column Attr1 
described in relation Table. 
The SELECT statement that follows the WITH clause will produce only those tuples where the 
value of Attr1 in relation Table is greater than the average value obtained from the WITH 
clause statement.

66
Example 1: Find all the employee whose salary is more than the average salary of all 
employees.
Name of the relation: Employee
EmployeeID
Name
Salary
100011
Smith
50000
100022
Bill
94000
100027
Sam
70550
100845
Walden
80000
115585
Erik
60000
1100070
Kate
69000
WITH temporaryTable(averageValue) as
(SELECT avg(Salary) from Employee)
SELECT EmployeeID,Name, Salary 
FROM Employee, temporaryTable
WHERE Employee.Salary > temporaryTable.averageValue;
EmployeeID
Name
Salary
100022
Bill
94000
100845
Walden
80000
The average salary of all employees is 70591. Therefore, all employees whose salary is 
more than the obtained average lies in the output relation.

67
Example 2: Find all the airlines where the total salary of all pilots in that airline is more than 
the average of total salary of all pilots in the database.
Name of the relation: Pilot
EmployeeID
Airline
Name
Salary
70007
Airbus 380
Kim
60000
70002
Boeing
Laura
20000
10027
Airbus 380
Will
80050
10778
Airbus 380
Warren
80780
115585
Boeing
Smith
25000
114070
Airbus 380
Katy
78000
WITH totalSalary(Airline, total) as
(SELECT Airline, sum(Salary)
FROM Pilot
GROUP BY Airline),
airlineAverage(avgSalary) as 
(SELECT avg(Salary)
FROM Pilot )
SELECT Airline
FROM totalSalary, airlineAverage
WHERE totalSalary.total > airlineAverage.avgSalary;
Airline
Airbus 380
The total salary of all pilots of Airbus 380 = 298,830 and that of Boeing = 45000. Average 
salary of all pilots in the table Pilot = 57305. 
Since only the total salary of all pilots of Airbus 380 is greater than the average salary 
obtained, so Airbus 380 lies in the output relation.

68
Important Points:
•The SQL WITH clause is good when used with complex SQL statements rather than 
simple ones
•It also allows you to break down complex SQL queries into smaller ones which make it 
easy for debugging and processing the complex queries.
•The SQL WITH clause is basically a drop-in replacement to the normal sub-query.

69
A recursive CTE is a subquery which refer to itself using its own name.
•The recursive CTEs are defined using WITH RECURSIVE clause.
•There should be a terminating condition to recursive CTE.
•The recursive CTEs are used for series generation and traversal of hierarchical or tree-
structured data.
Syntax:
WITH RECURSIVE 
cte_name [(col1, col2, ...)]
AS ( subquery )
Select col1, col2, .. from cte_name;
•
cte_name: Name given to recursive subquery written in subquery block.
•
col1, col2, ...colN: The name given to columns generated by subquery.
•
subquery: A Sql query that refer to itself using cte_name as its own name.
Here, the column names given in SELECT statement should match with the names provided in 
list followed by cte_name.

70
The recursive CTE structure provided in the subquery block:
Select col1, col2, ... coln from table_name
UNION [ALL, DISTINCT]
Select col1, col2, ...coln from cte_name
WHERE clause
The recursive CTE consist of a non-recursive subquery followed by a recursive subquery-
•The first select statement is a non-recursive statement, which provides initial rows for result set.
•UNION [ALL, DISTINCT] is use to add additional rows to previous result set. 
•The second select statement is a recursive statement which produces result set iteratively until 
the condition provided in WHERE clause is true.
•The result set produced at each iteration take result set produced at previous iteration as the 
base table.
•The recursion ends when the recursive select statement doesn’t produce any additional rows.

71
WITH RECURSIVE 
odd_no (sr_no, n) AS
(
SELECT 1, 1 
union all
SELECT sr_no+1, n+2 from odd_no where sr_no < 5 
)
Consider, following query which generate a series of first 5 odd numbers
+---------+-------+
| sr_no |  n    |
+---------+-------+
| 1       |  1    |
| 2       |  3    |
| 3       |  5    |
| 4       |  7    |
| 5       |  9    |
The above query consists of two parts- non-recursive and recursive.
Non-Recursive part- It will produce initial rows which consist of two columns named as 
“sr_no” and “n” and single row.
Query: SELECT 1, 1 
Output:
+---------+-------+
| sr_no   |  n    |
+---------+-------+
| 1       |  1    |
+---------+-------+
SELECT * FROM odd_no;

72
Recursive part-
SELECT sr_no+1, n+2 from cte where odd_no < 5 
It will add rows to previous output till the terminating condition i.e ( sr_no <5 ) is satisfied.
When, the sr_no become 5 the condition become false and the recursion is terminated.

An EXAMPLE of RECURSIVE 
Query
WITH RECURSIVE SUP_EMP (SupSsn, EmpSsn) AS
SELECT
SupervisorSsn, Ssn
FROM
EMPLOYEE
UNION
SELECT
E.Ssn, S.SupSsn
FROM
EMPLOYEE AS E, SUP_EMP AS S
WHERE
E.SupervisorSsn = S.EmpSsn)
SELECT
*
FROM
SUP_EMP;
The above query starts with an empty SUP_EMP and successively
builds SUP_EMP table by computing immediate supervisees first,
then second level supervisees, etc. until a fixed point is reached
and no more supervisees can be added

Use of CASE
SQL also has a CASE construct
Used when a value can be different based on certain conditions. 
Can be used in any part of an SQL query where a value is expected
Applicable when querying, inserting or updating tuples

EXAMPLE of use of CASE
The following example shows that employees are receiving different 
raises in different departments
UPDATE EMPLOYEE
SET
Salary = 
CASE
WHEN
Dno = 5 THEN
Salary + 2000
WHEN
Dno = 4 THEN
Salary + 1500
WHEN
Dno = 1 THEN
Salary + 3000

76
1. What are Assertions?
When a constraint involves 2 (or) more tables, the table constraint mechanism is sometimes 
hard and results may not come as expected. To cover such situation SQL supports the creation 
of assertions that are constraints not associated with only one table. And an assertion 
statement should ensure a certain condition will always exist in the database. DBMS always 
checks the assertion whenever modifications are done in the corresponding table.
CREATE ASSERTION  [ assertion_name ]
CHECK ( [ condition ] );
Specifying Constraints as Assertions 
and Actions as Triggers
Syntax
For example, to create an assertion called “salary_assertion” that checks that no 
employee in the “employees” table has a salary greater than $100,000, you could 
use the following statement:
CREATE ASSERTION salary_assertion
CHECK (salary <= 100000);

77
What are Triggers?
A trigger is a database object that is associated with the table, it will be activated when a 
defined action is executed for the table. The trigger can be executed when we run the 
following statements:
There are three types of triggers in SQL Server
DML triggers are automatically fired when an INSERT, UPDATE or DELETE event occurs on a 
table.
DDL triggers are automatically invoked when a CREATE, ALTER, or DROP event occurs in a 
database. It is fired in response to a server scoped or database scoped event.
Logon trigger is invoked when a LOGON event is raised when a user session is established.
create trigger [trigger_name]       
[before | after]          
{insert | update | delete} 
on [table_name]  
[for each row]    
[trigger_body] 
Syntax

AN EXAMPLE with standard Syntax.(Note : other SQL implementations 
like PostgreSQL use a different syntax.)
CREATE TRIGGER SALARY_VIOLATION
BEFORE INSERT OR UPDATE OF Salary, Supervisor_ssn ON
EMPLOYEE
FOR EACH ROW
WHEN (NEW.SALARY > ( SELECT Salary FROM EMPLOYEE
WHERE Ssn = NEW. Supervisor_Ssn))  
INFORM_SUPERVISOR (NEW.Supervisor.Ssn, New.Ssn)

Summary of SQL Queries
A query in SQL can consist of up to six clauses, but only the 
first two, SELECT and FROM, are mandatory. The clauses are 
specified in the following order:
SELECT
<attribute list>
FROM
<table list>
[WHERE
<condition>]
[GROUP BY <grouping attribute(s)>]
[HAVING
<group condition>]
[ORDER BY <attribute list>]

Summary of SQL Queries 
(cont.)
The SELECT-clause lists the attributes or functions to be retrieved
The FROM-clause specifies all relations (or aliases) needed in the 
query but not those needed in nested queries
The WHERE-clause specifies the conditions for selection and join of 
tuples from the relations specified in the FROM-clause
GROUP BY specifies grouping attributes
HAVING specifies a condition for selection of groups
ORDER BY specifies an order for displaying the result of a query

Relational Algebra Operations

82
List all the ids of the customer who have either purchased an item or 
their date of registration is not available. 
Retrieval using  UNION
The UNION operation
• Combines the rows from two sets of query results.
• By default, the UNION operation eliminates duplicate rows as part of its
processing.
SELECT CustomerId 
FROM Customer 
where DateOfReg is NULL
UNION
SELECT CustomerId
FROM CustomerPurchase;
Customer’s do 
not have date of 
registration
Customers 
having 
purchased

83
Union (Contd…)
CustomerId CustomerNAme DateOfReg
UserId
Password
C1
John
1-Mar-09
John1001
John@123
C2
Jack
10-Mar-09
Jack1002
Jack@123
C3 
Bob
12-Mar-09
Bob1003
Bob@123
C4
Allan
13-Mar-09
Allan1004
Allan@123
C5
Simon
Symon1005 Symon@123
CustomerId
ItemId
QtyPurchase
d
BillNo
NetPrice
C1
STN001
5
1001
150
C2
GRO001
1
1002
10
C1
ELC001
1
1001
5000
C2
STN002
2
1002
400
CustomerId
C5
CustomerId
C1
C2
C1
C2
UNION
CustomerId
C1
C2
C5

84
Union All
SELECT CustomerId  FROM Customer where 
DateOfReg IS NULL
UNION ALL
SELECT CustomerId  FROM
CustomerPurchase;
Union All returns all rows including duplicates selected by either query.

85
Union All
CustomerId CustomerNAme DateOfReg
UserId
Password
C1
John
1-Mar-09
John1001
John@123
C2
Jack
10-Mar-09
Jack1002
Jack@123
C3 
Bob
12-Mar-09
Bob1003
Bob@123
C4
Allan
13-Mar-09
Allan1004
Allan@123
C5
Simon
Symon1005 Symon@123
CustomerId
ItemId
QtyPurchase
d
BillNo
NetPrice
C1
STN001
5
1001
150
C2
GRO001
1
1002
10
C1
ELC001
1
1001
5000
C2
STN002
2
1002
400
CustomerId
C5
CustomerId
C1
C2
C1
C2
UNION 
ALL
CustomerId
C1
C2
C1
C2
C5

86
Union - Restrictions
The SELECT statements must contain the same number of columns
Data type
◦Each column in the first table must be the same as the data type of 
the corresponding column in the second table. 
◦Data width and column name can differ

87
List the id of customers who do not have date of registration but has 
purchased an item.
Retrieval using  INTERSECT
SELECT CustomerId
FROM Customer where 
DateOfReg IS NULL
INTERSECT
SELECT CustomerId
FROM CustomerPurchase;
Customers who 
do not have 
dateOf 
registration
Customerswho 
have purchased 
item

88
Minus
Get  the Id of all customers who have not purchased any items.
SELECT CustomerId 
FROM Customer
MINUS
SELECT CustomerId 
FROM CustomerPurchase;
Customers in the 
customer table
Customers who 
have purchased 
an item
This is the difference operation. It retrieves unique tuples which are present in 
relation 1 but not in relation 2.

89
Other Relational Algebra operations
Restriction
Projection
Join

90
Restriction
Restricts the rows that can be chosen from a relation using a WHERE clause
Takes a horizontal subset of values from the original relation
Example: 
SELECT * FROM Items WHERE UnitPrice > 100;
Where clause:
This will retrieve only those rows of the table which satisfy the condition in the 
where clause. Any logical conditions of the where clause use the comparison 
operators. Rows are returned or operated upon where the data satisfies the 
logical condition (s) of the where clause. 

91
Projection
Projection is projecting a set of attributes of a relation so that rows of values 
corresponding to those columns will figure in the output
This takes a vertical subset of the relation
Example:
SELECT ItemId, ItemName FROM Item;

92
Cartesian Product Or Cross Join
Returns All rows from first table, Each row from the first table is combined 
with all rows from the second table 
Example:
SELECT  *
FROM Table1,Table2;
A
B
C
a1
b1
c1
a2
b2
c2
X
Y
x1
y1
x2
y2
Cartesian Product
( m * n ) rows
A
B
C
X
a1
b1
c1
x1
a1
b1
c1
x2
a2
b2
c2
x1
Y
y1
y2
y1
a2
b2
c2
x2
y2
Table 1
Table 2
 Product of Table1 and Table2

93
JOINS
Inner join
Equi join
Outer join
◦Left-outer join
◦Right-outer join

94
Inner Joins
Common type of join
An inner join between two (or more) tables is the Cartesian product that 
satisfies the join condition in the WHERE clause 
Inner Joins:
The most common operator used to relate two tables is the equality operator (=). If 
you relate two tables using an equality operator, it is an equality join, also known as 
equijoin. This type of join combines rows from two tables that have equivalent values 
for the specified columns. A simple join is also known as an inner join, because it 
returns only the rows that satisfy the join condition.

95
+----+----------+-----+-----------+----------+
| ID | NAME     | AGE | ADDRESS   | SALARY   |
+----+----------+-----+-----------+----------+
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |
|  2 | Khilan |  25 | Delhi     |  1500.00 |
|  3 | kaushik |  23 | Kota      |  2000.00 |
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |
|  6 | Komal    |  22 | MP        |  4500.00 |
|  7 | Muffy    |  24 | Indore    | 10000.00 |
+----+----------+-----+-----------+----------+
CUSTOMERS Table
ORDERS Table
+-----+---------------------+-------------+--------+
| OID | DATE              | CUSTOMER_ID | AMOUNT 
+-----+---------------------+-------------+--------+
| 102 | 2009-10-08 00:00:00 |           3 |   3000 |
| 100 | 2009-10-08 00:00:00 |           3 |   1500 |
| 101 | 2009-11-20 00:00:00 |           2 |   1560 |
| 103 | 2008-05-20 00:00:00 |           4 |   2060 |
+-----+---------------------+-------------+--------+
SELECT  ID, NAME, AMOUNT, DATE
FROM CUSTOMERS
INNER JOIN 
ORDERS ON CUSTOMERS.ID = 
ORDERS.CUSTOMER_ID;
+----+----------+--------+---------------------+
| ID | NAME     | AMOUNT | DATE                |
+----+----------+--------+---------------------+
|  3 | kaushik |   3000 | 2009-10-08 00:00:00 |
|  3 | kaushik |   1500 | 2009-10-08 00:00:00 |
|  2 | Khilan |   1560 | 2009-11-20 00:00:00 |
|  4 | Chaitali |   2060 | 2008-05-20 00:00:00 |
+----+----------+--------+---------------------+

96
Get all combinations of emp and cust information such that the emp and 
cust are co-located.
SELECT Table1.Emp_ID, Table1.City, Table2.Cust_ID, Table2.City
FROM Table1, Table2
WHERE Table1.City = Table2.City;
Retrieval from Multiple tables-Equi join
Emp_ID
CITY
A1
New YorK
A2
NULL
A3
Chicago
A4
Chicago
A5
Paris
Cust_ID
CITY
B1
New York
B2
New York
B3
NULL
B4
Chicago
B5
Moscow
Table1
Table2
Table1.Emp_ID Table1.City Table2.Cust_ID
Table2.City
A1
New York
B1
New York
A1
New York
B2
New York
A3
Chicago
B4
Chicago
A4
Chicago
B4
Chicago
INNER
JOIN
Output Table
Here the where clause is based 
on the equality condition “=“. 
Hence it is called equi join

97
Display the Employee number, Employee name and department 
name of the employees who are working for some department.
SELECT EmpNo, EName,DName
FROM Emp E , Dept D
WHERE E.DeptNo = D.DeptNo;
Retrieval from Multiple tables- Equi join

98
Display the details of the customers who have purchase items
SELECT a.CustomerId,a.CustomerName
FROM Customer a, CustomerPurchase b
WHERE a.CustomerId = b.CustomerId;
Retrieval from Multiple tables- Equi join
Display the details of suppliers who have been ordered to supply 
item but the delivery status is ‘Not Delivered’.
SELECT s.SupplierId,s.SupplierName
FROM Supplier s, ItemOrder io
WHERE s.SupplierId = io.SupplierId AND
io.DeleviryStatus=‘Not Delivered’;

99
Display the details of Supplier who has been ordered to deliver 
more than one item
Retrieval from Multiple tables- Equi join
SELECT s.SupplierId,s.SupplierName
FROM Supplier s, ItemOrder io
WHERE s.SupplierId = io.SupplierId 
Group By s.SupplierId,s.SupplierName
having count(*)>1;

100
Display the name of the item, name of the supplier and quantity 
supplied if the supplier has been ordered to supply that item.
Retrieval from Multiple tables- Equi join
SELECT i.ItemId,s.SupplierId,io.QtyOfOrder
FROM Item i, Supplier s, ItemOrder io
WHERE s.SupplierId = io.SupplierId  
AND i.ItemId=io.ItemId;

101
Display the id and name of the customer and the total amount of 
purchasing done so far from the retail shop.
Retrieval from Multiple tables- Equi join
SELECT c.CustomerId,c.CustomerName,Sum(cp.NetPrice)
FROM Customer c, CustomerPurchase cp
WHERE c.CustomerId=cp.CustomerId
Group by c.CustomerId,c.CustomerName;

102
Display customer id ,customer name ,bill id and the total amount of 
purchasing done by the customer on that bill.
Note: A customer may have paid several bills 
Retrieval from Multiple tables- Equi join
SELECT
c.CustomerId,c.CustomerName,cp.BillId,Sum(cp.NetPrice)
FROM Customer c, CustomerPurchase cp
WHERE c.CustomerId=cp.CustomerId
Group by c.CustomerId, c.CustomerName, cp.BillId;

103
Display the id and name of the customer along with the bill id and 
bill date if the total amount of the bill is more than 1000; 
Retrieval from Multiple tables- Equi join
SELECT c.CustomerId,c.CustomerName,
b.BillId,b.BillDate,Sum(cp.NetPrice)
FROM Customer c, CustomerPurchase cp,Bill b
WHERE c.CustomerId=cp.CustomerId AND
cp.BillId=b.billId
Group by c.CustomerId, c.CustomerName,
b.BillId,b.BillDate
HAVING Sum(cp.NetPrice)>1000;

104
Outer join
Retrieve all rows that match the WHERE clause and also those that have a 
NULL value in the column used for join. 
The inner join takes into account only those non NULL rows from the tables 
involved. If you want the result to include even those rows having a NULL for a 
particular row in the selected column, then go for an outer join. 

105
Left / Right-Outer join
Left outer joins include all records from the first (left) of two tables, 
A = B (+)                          
Syntax:
SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;     
Example
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
ORDER BY Customers.CustomerName;
Note: The LEFT JOIN keyword returns all records from the left 
table (Customers), even if there are no matches in the right table 
(Orders).

106
Right outer joins include all records from the second (right) of two tables, 
A (+) = B
The RIGHT JOIN keyword returns all records from the right table (table2), and the matching 
records from the left table (table1). The result is 0 records from the left side, if there is no 
match.
Syntax 
SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
Note: In some databases RIGHT JOIN is called RIGHT OUTER JOIN.
Example:
SELECT Orders.OrderID, Employees.LastName, 
Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = 
Employees.EmployeeID
ORDER BY Orders.OrderID;

107
Example of left-join
SELECT Table1.Emp_ID, Table1.City, Table2.Cust_ID, Table2.City
FROM Table1, Table2
WHERE Table1.City = Table2.City (+);
List all cities of Table1 if there is match in cities in Table2 & also unmatched 
Cities from Table1
Emp_ID
CITY
A1
New YorK
A2
NULL
A3
Chicago
A4
Chicago
A5
Paris
Cust_ID
CITY
B1
New York
B2
New York
B3
NULL
B4
Chicago
B5
Moscow
Table1
Table2
Table1.Emp_ID Table1.City Table2.Cust_ID
Table2.City
A1
New York
B1
New York
A1
New York
B2
New York
A3
Chicago
B4
Chicago
A4
Chicago
B4
Chicago
A5
Paris
NULL
NULL
A2
NULL
NULL
NULL
INNER
JOIN
Unmatched
rows
Left_Outer_Join Table

108
Example of Left Outer Join
List customer id, customer name and item Id if the customer has
purchased the item. In case customer has not purchased the item
then item id should not be displayed in front of customer id and
customer name.
SELECT  C.Customerid, C.CustomerName,IP.ItemId,
FROM Customer C, ItemPurchase IP
WHERE C.CustomerId = IP.CustomerId(+);

109
Example of right outer join
SELECT Table1.Emp_ID, Table1.City, Table2.Cust_ID, 
Table2.City
FROM Table1, Table2
WHERE Table1.City (+) = Table2.City; 
Emp_ID
CITY
A1
New YorK
A2
NULL
A3
Chicago
A4
Chicago
A5
Paris
Cust_ID
CITY
B1
New York
B2
New York
B3
NULL
B4
Chicago
B5
Moscow
Table1
Table2
Table1.Emp_ID Table1.City Table2.Cust_ID
Table2.City
A1
New York
B1
New York
A1
New York
B2
New York
A3
Chicago
B4
Chicago
A4
Chicago
B4
Chicago
NULL
NULL
B5
Moscow
NULL
NULL
B3
NULL
INNER
JOIN
Unmatched rows
Right_Outer_Join Table

110
SQL Self Join
A self join is a regular join, but the table is joined with itself.
Self Join Syntax
SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
T1 and T2 are different table aliases for the same table.
Example:
SELECT  a.ID, b.NAME, a.SALARY
FROM CUSTOMERS a, CUSTOMERS b
WHERE a.SALARY < b.SALARY;

